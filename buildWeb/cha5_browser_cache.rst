浏览器缓存
================

服务器端有多种缓存机制可以使Web产品的性能得以提升，而作为客户端的浏览器也具备缓存的功能，使用得当的话，会有更有效的性能提升。

别忘了浏览器
-----------

浏览器具备缓存Web服务器上资源的功能，这样方便用户访问Web资源，同时也可以减轻服务器的请求压力。音频或视频的网站，浏览器缓存对于用户体验和缓解服务器压力可以说起着至关重要的作用。

浏览器不只是用户的
~~~~~~~~~~~~~~~~~~~

可以把浏览器想象成Web服务器的缓存管理器，使用得当的话，既可以缓解服务器压力，又可以提升用户体验。

缓存放在哪里
~~~~~~~~~~~~~~~~~~

不同的浏览器，缓存机制和缓存文件存在的方式是不一样的。如，ie浏览器在用户的文件系统中创建了一个缓存目录，缓存的内容直接以文件的方式存在于缓存目录下；火狐浏览器则是把缓存内容以二进制的形式存放在指定的缓存目录中，需要使用火狐自带的工具（如about:cache）查看缓存内容。缓存文件除了保存了缓存的数据外，还记录了缓存的上次修改时间、过期时间和上次检查时间等信息，以便进行缓存的过期检查。过期检查是浏览器缓存至关重要的一个环节。

缓存协商
-----------

浏览器的缓存需要浏览器和Web服务器协商完成，而HTTP协议中的“缓存协商”则是这种缓存机制实现的基础。浏览器通常只对GET类型的请求使用本地缓存。

    * 协商过程：浏览器向Web服务器发起请求；Web服务器告诉浏览器哪些内容可以缓存；针对Web服务器运行浏览器缓存的内容，浏览器第二次请求这个内容时，不是要获取内容，而是询问是否可以使用本地的缓存；Web服务器决定是否允许浏览器使用缓存。
    * 做好协商准备：部署一个不启用浏览器缓存的Web资源，通过观察请求该资源时的头信息，了解跟浏览器缓存相关的“最后修改时间”等请求头信息；
    * Last-Modified：动态内容不存在最后修改时间，Web服务器会为静态文件的HTTP响应头自动生成最后修改时间，可以通过PHP的header函数为动态资源生成最后修改时间，如header('Last-modified: ' . gmdate('D, d M Y H:i:s') . ' GMT');
    * 处理浏览器的询问：浏览器的请求头中会使用“If-Modified-Since”向Web服务器询问：该请求资源在指定的时间后是否发生有了更新。如果是静态内容，Web服务器会对比请求中的时间和静态文件的最后修改时间来决定是否允许浏览器使用本地缓存。对允许使用浏览器缓存的内容，Web服务器不返回资源的内容，状态码也不是200而是304（Not Modified）。针对文件修改时间更新，但内容更新，或者使用了负载均衡的Web服务器来说，基于最后修改时间判断是否使用浏览器缓存存在一定的局限性；
    * ETag协商机制：HTTP/1.1支持ETag浏览器缓存协商机制，即采用Web发育完全为每个资源生成一个ETag编码的方式来验证请求的资源是否可以使用浏览器本地缓存，响应头中会有ETag标记资源的ETag值，请求头中则使用If-None-match询问是否允许使用浏览器缓存；
    * 让动态内容学会和浏览器交流：可以借助PHP的SERVER全局变量的HTTP_IF_MODIFIED_SINCE和header函数制定状态码的方式完成动态内容的浏览器缓存功能；需要说明的是，动态内容的缓存可以使带宽的使用量大幅度降低，但在并发数上可能并不是太有优势（如果请求内容资源比较大的时候，并发的提升也是比较可观的）；
    * SSI和Last-Modified：SSI使用浏览器缓存需要针对不同的浏览器做一些额外的配置；

彻底消灭请求
---------------

    * 浏览器缓存截止日期：借助HTTP的Expires标记，可以指定内容的过期时间，浏览器可以在过期之前直接使用本地缓存而不需要请求服务器；Web服务器通常不开启Expires标记支持，需要手动修改Web服务器的配置文件实现Expires的设置；
    * 

