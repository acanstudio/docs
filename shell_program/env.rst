环境与继承
========================

shell进程启动运行后，从login程序那里继承了许多变量、I/O流和进程特性，shell派生出的子进程也会继承到这些信息。这些信息又称为进行的运行环境，信息可以分为进程权限、工作目录、文件的创建掩码、
特殊变量、打开文件和信号

进程权限和用户的所有权
----------------------

系统会为成功登录的用户分配一些身份信息：一个真实用户标识（UID）；一个活多个真实用户组标识（GID）；一个有效用户标识（EUID）；有效用户组标识（EGID）。这些信息保存在passwd文件中。
EUID和EGID决定了进程读、写和执行文件时的访问权限。如果EUID与文件所有者的UID相同，则进程具有文件的所有者访问权限，如果进程的EGID和GID相同，则进程拥有所有者组的权限。

命令id可以查看当前用户的UID和GID信息，用户登录后，shell进程会继承到登录用户的UID和GID值，之后shell的子进程也都会继承它的权限。开始时，EUID和EGID分别于UID和GID相同。进程运行的过程中，可以
通过setuid和setgid程序修改EUID和EGID为另一个所有者的ID，从而使进程拥有其他用户的执行权限。如程序passwd就是一个setid程序，普通用户执行passwd的时候，会修改/etc/passwd文件的内容，而/etc/passwd
文件只有root用户可以读写。也就是说passwd程序执行过程中把EUID和EGID设置为了root账号的UID和GID。使用setuid和setgid时要慎重，使用不当会有安全漏洞。shell允许用户创建setuid脚本，sell本身也可以是
setuid程序。

掩码的作用
---------------

创建文件或目录时，会生成一组默认的权限，这组权限由创建文件的进程当前的默认掩码决定。用户可以通过命令umask来修改掩码的值，也可以在shell的初始化文件中设置一个umask值，从而使新创建的文件和
目录具有指定的一些权限。umask的初始值为000，系统通常会在/bin/login或初始化文件/etc/profile中把umask设置为022，新创建的目录的默认权限是：777-022（umask值）=755；新创建的文件的默认权限是
666-022（umask值）=644。

修改权限和所有者
-----------------

每个UNIX/Linux文件都有一组控制其读写和执行的权限集合，每个UNIX/Linux文件有且只有一个所有者，只有所有者或超级用户可以使用chmod命令改变文件或目录的权限。一个用户组可以有多个成员，文件的
所有者或超级用户可以改变文件的组权限。ls -l可以查看文件的权限。文件的权限由9个二进制位组成，每三位一组，分别控制文件所有者的权限，控制文件的组权限，控制其他人的权限。文件的权限保存在
inode的mode字段里。文件的所有者或超级用户可以通过chmod改变文件的权限，chmod设计到的符合及含义是：r=read, w=write, x=excute, u=user, g=group, o=others, a=ll。chmod的示例如下：
chmod 755 file; chmod g+w file; chmod go-rx file; chmod a=r file。

只有超级用户可以通过chown改变文件的所有者，如：chown root file; chown root:root file;

工作目录
----------

用户登录成功后，会在文件系统中得到一个工作目录，称为主目录（home directory）。工作目录会被shell派生的进程继承，shell任何一个子进程都可以改变自己的工作目录，但子进程对工作目录的改变不影响
父进程的工作目录。常用的改变工作目录的命令cd是一个shell的内置命令，内置命令是shell的一部分，由shell直接运行。运行内部命令时，shell不适用fork和exec。

变量
-------

shell可以定义两类变量：局部变量和环境变量。这些变量包含了用于订制shell的信息，以及其他进程正确运行所需要的信息。局部变量只属于创建它们的shell，不会传递给该shell派生的子进程。内置命令set
可以查看shell的局部变量。环境变量会被shell传递给它派生的子进程，而且子进程还会把它们传递给由子进程又创建的子进程。部分环境变量是登录shell从/bin/login继承的，其他的则是由用户的初始化文件
脚本或命令行创建的。如果环境变量在子进程中设置，它不会回传给父进程。shell的env可以查看环境变量。

重定向与管道
-------------

所有I/O，包括文件、管道和套接字，都是有内核通过一种文件描述符的极致进行管理的，文件描述符是一个比较小的无符号整数，是文件描述附表的索引。文件描述符表由内核维护，内核用它访问打开的文件和
I/O流，每个进程都会从它的父进程那边继承文件描述符表。头三个文件描述符为0（stdin，标准输入），1（stdout，标准输出），3（stderr，标准错误输出），之后，会为每打开的一个文件分配一个文件描述
符，如果所有的文件描述符都用掉了，就不能再打开文件了。limit和ulimit命令可以设置文件描述符的个数。

当文件描述符被分配给终端以外的对象时，就被称为I/O重定向。shell把输出重定向一个文件的过程是：关闭标准文件描述符1（终端）；然后把这个描述符分配给该文件。重定向标准输入：关闭文件描述符0（终端）
然后将它分配给一个文件。标准错误输出的重定向：关闭标准错误输出描述符3（终端），然后将描述符分配给一个文件，具体实现时，C&TC shell与Bourne，Korn和Bash等shell会有所不同。重定向的示例：
who > file # 标准输出重定向; cat file1 file2 >> file3 # 重定向追加输出; mail tom < file # 标准输入重定向; find /-name file -print 2> errors # Bash，Bourne和Korn shell的标准错误重定向;
( fined / -name file -print > /dev/tty) >& errors # C&TC shell的标准错误输出重定向;

管道是进程间通信的一种方式，用来将一条命令的输出传递给应一条命令作输入，通常仅在父进程和子进程之间单向传递数据。shell通过关闭和打开文件描述符来实现管道，但此时文件描述符并非分配给文件，
而是赋给由系统调用pipe生成的管道描述符。创建管道文件描述符后，父进程为管道中每条命令派生一个子进程，子进程分别操纵管道描述符，一个往管道写数据，另一个则是从管道读数据。管道其实就是一个
内核缓冲区，两个进程通过它来共享数据。内核负责协调两个进程向缓冲区读写数据的操作。

shell和信号
--------------

进程在执行的过程中，会接收到一些信号，如段冲突、总线错误、电源故障或程序出错等意外事件会向进程发送信号，用户也可以通过键入Break、Delete、Quit或Stop等想进程发送信号，还可以使用kill命令向
进程发送信号，大部分信号会终止进程。进程对给定信号可采取的动作有：忽略信号、停止进程、继续进程、进程可以被程序中定义的函数所捕获。Bourne、Korn和Bash可以通过设置特定信号的相应动作来捕获或
忽略信号。C&TC shell只能处理Ctrl+C终端信号。

标准信号：

+-------+----------+----------------------------------+------------+
|  编号 |   名称   |     描述                         |  动作      |
+=======+==========+==================================+============+
|   0   |  EXIT    | shell退出                        |  终止      |
+-------+----------+----------------------------------+------------+
|   1   |  SIGHUP  | 终端已断开                       |  终止      |
+-------+----------+----------------------------------+------------+
|   2   |  SIGINT  | 用户按了Ctrl+C                   |  终止      |
+-------+----------+----------------------------------+------------+
|   3   |  SIGQUIT | 用户按了Ctrl+\                   |  终止      |
+-------+----------+----------------------------------+------------+
|   4   |  SIGILL  | 非法硬件指令                     |  程序错误  |
+-------+----------+----------------------------------+------------+
|   5   |  SIGTRAP | 调试程序产生                     |  程序错误  |
+-------+----------+----------------------------------+------------+
|   8   |  SIGFPE  | 算术错误，如除数为0              |  程序错误  |
+-------+----------+----------------------------------+------------+
|   9   |  SIGKILL | 不能捕获或忽略                   |  终止      |
+-------+----------+----------------------------------+------------+
|  10   |  SIGUSR1 | 应用程序定义的用户信号           |            |
+-------+----------+----------------------------------+------------+
|  11   |  SIGSEGV | 无效的内存引用                   |  程序错误  |
+-------+----------+----------------------------------+------------+
|  12   |  SIGUSR2 | 应用程序定义的用户信号           |            |
+-------+----------+----------------------------------+------------+
|  13   |  SIGPIPE | 断开管道连接                     |  操作错误  |
+-------+----------+----------------------------------+------------+
|  14   |  SIGALRM | 超时                             |  发出警告  |
+-------+----------+----------------------------------+------------+
|  15   |  SIGTERM | 程序终止                         |  终止      |
+-------+----------+----------------------------------+------------+
|  17   |  SIGCHLD | 子进程停止或死亡                 |  忽略      |
+-------+----------+----------------------------------+------------+
|  18   |  SIGCONT | 启动已停止的作业，此信号不能跳过 |  继续作业  |
+-------+----------+----------------------------------+------------+
|  19   |  SIGSTOP | 停止一项作业，此信号不能跳过     |  停止进程  |
+-------+----------+----------------------------------+------------+
|  20   |  SIGSTP  | 交互停止，用户需按Ctrl+Z组合键   |  停止进程  |
+-------+----------+----------------------------------+------------+
|  21   |  SIGTTIN | 后台作业尝试从控制终端读取信息   |  停止进程  |
+-------+----------+----------------------------------+------------+
|  22   |  SIGTTOU | 后台作业尝试向控制终端写入信息   |  停止进程  |
+-------+----------+----------------------------------+------------+
