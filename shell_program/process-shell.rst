进程与shell
========================

进程是正在运行的程序，由系统内核负责控制和管理，内核为每个进程分配一个唯一的进程标识，process identification，即PID号。进程由可执行程序、进程数据和堆栈、程序指针和堆栈指针、寄存器一级程序
运行时需要的所有信息组成。用户登录成功后，shell程序自动加载，形成一个shell进程，并且属于某个进程组。任何时候只能有一个进程组拥有终端控制权，即所谓的在前台运行。shell进程启动后，便控制可终端。
UNIX/Linux内核管理并控制着多个进程，为每个进程分配CPU时间。

常用与进程相关的命令
---------------------

ps
~~~~~~~~~~

ps命令和它的诸多选项能够以多种格式列出当前正在运行进程的一些信息。如由用户运行的所有进程信息的命令是：ps aux （BSD/Linux ps）； （use ps -ef for SVR4）

pstree/ptree命令
~~~~~~~~~~~~

pstree（Linux系统适用，Solaris是ptree）用来查看进程运行情况，并以树状的形式展示出进程的继承关系。树的根通常是init进程，如果指定了用户名，则树的根是用户进程。如果一个进程派生了多个同名进程
，pstree将同样的分支用方括号组合起来，并以进程的个数作为前缀来表名子进程的个数。


系统调用
------------------

shell可以通过系统调用派生出其他进程，系统调用是对内核服务的请求，进程访问系统硬件只能通过系统调用来实现。在shell下输入命令或运行脚本时，shell负责找到相应的程序并执行。有大量的系统调用
可以创建、执行和终止进程。

创建进程
------------------

系统调用fork
~~~~~~~~~~

进程的创建是通过系统调用fork来完成的，fork创建调用进程的一个副本，新创建的进程称为子进程（child），创建它的进程称为父进程（parent），fork调用完成后，子进程立即开始运行，最初阶段，父子进程
共享CPU，子进程还会得到父进程信息的副本，包括环境，打开的文件、真实且有效的用户标识，umask，当前工作目录和信号等

用户输入命令后，shell开始解析命令行，如果输入的命令是内置命令，就由shell直接运行；如果是磁盘命令，shell就调用fork创建一个子进程，子进程负责找到命令，并初始化命令执行的环境信息，如配置用
于重定向的文件描述符、管道、命令替换和后台处理。子shell运行时，父shell通常处于睡眠状态。

系统调用wait
~~~~~~~~~~~~

系统调用wait导致父进程挂起直至它的一个子进程终止。如果wait调用成功，将返回终止的子进程的PID和子进程退出状态。如果父进程没有wait，子进程终止后就进入了僵尸状态，并且保持这种状态直至父进程
调用wait或死亡。如果父进程先于子进程死亡，则由init进程处理遗留的僵尸子进程。因此，系统调用wait不仅用于让父进程进入睡眠状态，还可用于保证子进程正常终止。

系统调用exec
~~~~~~~~~~~~~

终端输入一条命令后，shell通常派生出一个新的shell子进程，shell子进程通过exec去执行输入的命令（命令通常是一个可执行程序）。exec把新程序加载到内存，替换掉调用它的shell，新程序称为新的当前
进程开始执行。新进程有自己的局部变量，但所有的环境变量、打开的文件、信号和当前工作目录会保留。进程结束后退出并唤醒父shell。

系统调用exit
~~~~~~~~~~~~~

进程随时都可以通过调用exit终止，子进程终止时，会向父进程发出一个信号（sigchild）并等待父进程接受它的退出状态。退出状态是一个0-255之间的一个数字，0子进程执行成功，其他值则说明发生了某种
错误。

系统调用的示例及说明
~~~~~~~~~~~~~~~~~~~~~~~~

下面通过grep命令在shell下的执行过程为例，说明进程和系统调用的的一个应用场景：

    * 父shell通过系统调用fork创建一个自己的副本，这个副本为子shell；
    * 子shell有一个新的PID，将和父进程共享CPU；
    * 内核把grep程序载入内存，通过系统调用exec执行grep命令，此时grep程序替换掉了子shell，并继承了子shell的打开的文件和工作环境，子shell和grep使用同一个PID；
    * grep程序退出，内核通过exit完成清理工作，并唤醒父进程。

shell中提供了一个特殊的内置变量来保存上一条命令的退出状态，C&TC shell中是$status，Bourne、bash、Korn等shell下是$?。如：% cp abc def; echo $status (echo $?);可以查看cp命令执行的状态。

运行中的进程可以通过Ctrl+C或kill命令来终止。kill是一个内置shell命令，通过PID终止进程，如果使用了作业控制的话，也可以通过作业号终止作业。