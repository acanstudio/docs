排序
=========

排序的基本概念与分类
-----------------------

假设含有n个记录的序列{r1,...,rn},其对应的关键字分别是{k1,...,kn}，需要构造{p1,...,pn}排列，使其对应的关键字满足kp1<=kp2<...<kpn，也就是使得序列称为一个按关键字有序的序列{rp1,...,rpn}，这样的操作称为排序。

排序时依据关键字之间的大小关系，同一个记录集合，针对不同的关键字排序，得到不同的序列。关键字可以是主关键字，也可以是次关键字，还可以是若干关键字的组合。

排序的稳定性，假设Ki=Kj(1<=i<=n;1<=j<=n;i!=j)，且在排序前的序列中ri领先与rj(即i<j)，如果排序后ri仍领先与rj，则称所用的排序方法是稳定的，反之，若排序后rj领先ri，则称排序方法是不稳定的。排序方法是否稳定，要分析后才能得出。

内排序是在排序整个过程中，待排序的所有记录全部放置在内存中，外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

内排序的性能因素：
* 时间性能，内排序中的主要操作有比较和移动，高效的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数；
* 辅助空间，排序算法执行过程中需要借助的存储空间越少越好；
算法的复杂性，这里指算法本身的复杂度，而不是指时间复杂度；

基于排序过程中的主要操作，可分为插入排序、交换排序、选择排序和归并排序。

排序用到的结构和函数
<pre>
// 顺序表结构
#define MAXSIZE 10 // 排序数组个数
typedef struct
{
  int r[MAXSIZE + 1]; // 存储要排序数组，r[0]用作哨兵或临时变量
  int length; // 记录顺序表的长度
} SqList;

// 元素交换函数，交换L中数组r的下标为i和j的值
void swap(SqList *L, int i, int j)
{
  int tmp = L->r[i];
  L->r[i] = L->r[j];
  L->r[j] = temp;
}
</pre>

冒泡排序
----------

简单选择排序
-------------

简单选择排序法(Simple Selection Sort)就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1<=i<=n)个记录交换之。

<pre>
// 对有序表L作简单选择排序
void SelectSort(SqList *L)
{
  int i, j, min;
  for (i = 1; i < L->length; i++) {
    min = i; // 将当前下标定义为最小值下标
    for (j = i + 1; j <= L->length; j++ ) { // 循环之后的数据
      if (L->r[min] > L->r[j]) { // 若果小于当前最小值，替换min
        min = j;
      }
    }
    if (i != min) {
      swap(L, i, min);
    }
  }
}
</pre>

简单选择排序最大的特点就是交换移动次数相当少，比较次数为n(n-1)/2，交换次数，最少为0次，最多为n-1次，总的时间复杂度为O(n^2)。

直接插入排序
--------------

直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数加1的有序表。

<pre>
// 对有序表L作直接插入排序
void InsertSort(SqList *L)
{
  int i, j;
  for (i = 2; i <= L->length; i++) {
    if (L->r[i] < L->r[i - 1]) { // 需将L->r[i]插入有序字表
      L->r[0] = L->r[i]; // 设置哨兵
      for (j = i - 1; L->r[j] > L->r[0]; j--) {
        L->r[j + 1] = L->r[j]; // 记录后移
      }
      L->r[j + 1] = L->r[0]; // 插入到正确位置
    }
  }
}
</pre>

从空间上看，只需要一个记录的辅助空间，时间复杂度最好的情况下是O(n)，最差的是比较(n+2)(n-1)/2，记录移动次数(n+4)(n-1)/2，时间复杂度是O(n^2)。比冒泡和简单选择排序的性能好一些。

希尔排序
-----------

堆排序
-------

归并排序
-----------

快速排序
---------

总结
-------
