查找
=====

查找概论
---------

查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据记录。

* 查找表(Search Table) 是由同一类型的数据元素构成的集合；
* 关键字(Key)是数据元素中某个数据项的值，可以标识一个数据元素，也可以标识一个元素的某个数据项(字段)，又称键值或关键码；
* 主关键字(PrimaryKey)可以唯一标识一个元素，主关键字所在的数据项称为主关键码；
* 次关键字(SecondarKey)可以识别多个数据元素的关键字；

查找表之静态查找表(Static Search Table)：只做查找操作的查找表，主要操作有
* 查询某个“特定”数据元素是否在查找表中；
* 检索某个“特定”数据元素和各种属性；

查找表之动态查找表(Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素
* 查找时插入数据元素；
* 查找时删除数据元素

通常被查找的数据元素之间没有本质关系，只是简单的一个集合，为了获得较高的查找性能，通过改变数据结构，将原本是集合的构造成表或树等结构。为了提高查找效率，需要专门设置数据结构，这种面向查找操作的数据结构称为查找结构。

顺序表查找
----------

有序表查找
-----------

线性索引查找
----------------

二叉排序树
-----------

平衡二叉树（AVL树）
--------------------

多路查找树（B树）
-----------------

散列表查找（哈希表）概述
--------------------------

存储位置=f(关键字)，可以通过查找关键字不需要比较就可获得需要的记录的存储位置，这种跟存储相关的技术成为散列技术。

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。对应关系f成为散列函数，也称作哈希(Hash)函数。采用散列结束将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)，关键字对应的记录存储位置称为散列地址。

散列技术既是一种存储方法，也是一种查找方法，散列表查找步骤
* 存储时通过散列函数计算记录的散列地址，按散列地址存储记录；
* 查找记录时，通过同样的散列函数计算记录的散列地址，按散列地址访问记录；

散列技术最适合的求解问题是超找与给定值相等的记录，对于查找来说，简化了比较的过程；散列技术不具备很多常规数据结构的能力；散列表不适合范围查找；

设计一个简单、均匀、存储利用率高的散列函数是散列技术的关键；每个关键字通过散列函数计算出来的地址应该都是不一样的，如果关键字key1!=key2，但f(key1)=f(key2)，这种现象称为冲突(collision)，把key1和key2称为散列函数同义词(synonym)；防止冲突也是设计散列函数的一个重点。

散列函数的构造方法
--------------------

构造散列函数的原则
* 计算简单
* 散列地址分布均匀，保证存储空间的有效利用，减少处理冲突二消耗时间；

散列函数构造的方法
* 直接定址法，取关键字的某个现行函数值作为散列地址，f(key)=a*key+b；优点，简单均匀，不冲突；缺点事先知道关键字的分布情况，适合查找表小且连续的情况；
* 数字分析法，使用关键字的一部分来计算散列存储位置的方法；适合处理关键字位数较大，如果事先知道关键字的分布且关键字的若干位分布较均匀；
* 平方取中法，如针对关键字1234，先平方得到1522756，抽取中间三位227用作散列地址；适合不知道关键字的分布，而位数又不是很大的情况；
* 折叠法，如针对关键字9876543210，先分组987,654,321,0，叠加求和得1962，取最后三位作为散列地址962；适合事先不知道关键字的分布，且关键字位数较多的情况；
* 除留余数法，对于散列表长为m的散列函数公式为：f(key)=key mod p (p<=m)；可以跟别的方法结合使用；关键在于选择合适的p；否则容易产生同义词；经验：若散列表长为m，通常p为小于或等于表厂的最小质数或不包含小于20质因子的合数；
* 随机数法，取关键字的随机函数值作为它的散列地址，f(key)=random(key)；当关键字长度不等时，可以考虑这个办法；

构造散列函数时要考虑的因素
* 计算散列地址所需的时间；
* 关键字的长度；
* 散列表的大小；
* 关键字的分布情况；
* 记录查找的频率；

处理散列冲突的方法
---------------------

散列的冲突问题无法避免，但却可以修补冲突，使冲突的副作用降到最低。

开放定址法
一旦发生了冲突，寻找下一个空的散列地址，将记录存入新的散列地址；fi(key) = (f(key) + di) MOD m (di=1,2,...,m-1)；
这种解决冲突的开放定址法称为线性探测法；解决冲突过程中，本来不是同义词，却需要争夺一个地址的现象称为堆积；
fi(key)=(f(key) + di) MOD m (di=1^2,-1^2, ...,q^2,-q^2 q<=m/2)；二次探测法；
fi(key)=(f(key) + di) MOD m (di = 随机数)；随机探测法；

在散列函数法
事先预备多个散列函数fi(key)=RHi(key) (i=1,...,k)；档冲突发生时，换用另一个散列函数；

连地址法
将关键字为同义词的记录存储在一个单链表中，这种表又称为同义词子表；散列表中只存储同义词子表的头指针；冲突发生时，增加指定位置单链表的结点即可；

公共溢出区法
为所有冲突的关键字建立一个公共的溢出区来存放；

散列表查找实现
----------------

散列表结构的定义
<pre>
#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12 // 散列表长
#define NULLKEY -32768
typedef struct
{
  int *elem; // 散列表存储基址，动态分配数组
  int count; // 当前数据元素个数
} HashTable;
int m = 0; // 散列表表长，全局变量

// 散列表初始化
Status InitHashTable(HashTable *H)
{
  int i;
  m = HASHSIZE;
  H->count = m;
  H->elem = (int *)malloc(m *sizeof(int));
  for (i = 0; i < m; i++) {
    H->elem[i] = NULLKEY;
  }

  return true;
}

// 散列函数
int Hash(int key)
{
  return key % m; // 除留余数法
}

// 为关键字生产散列地址，存储关键字信息
void InsertHash(HashTable *H, int key)
{
  int addr = Hash(key); // 求散列地址
  while (H->elem[addr] != NULLKEY) { // 有冲突
    addr = (addr + 1) % m;
  }
  H->elem[addr] = key;
}

// 散列表查找关键字
Status SearchHash(HashTable H, int key, int *addr)
{
  *addr = Hash(key); // 求散列地址
  while (H.elem[*addr] != key) { // 有冲突
    *addr = (*addr + 1) % m;
    if (H.elem[*addr] == NULLKEY || *addr == Hash(key)) { // 如果循环到原点
      return UNSUCCESS;
    }
  }
  return SUCCESS;
}
</pre>

散列查找表性能分析
没有冲突时，查找的时间复杂度为O(1)，一般情况，影响性能的因素有
* 散列函数是否均匀，决定了冲突的频率
* 处理冲突的方法
* 散列表的装填因子，装填因子=填入表中的记录个数/散列表长度；散列表的平均查找长度取决于装填因子，而不是取决于查找机会中的记录个数；

总结
---------
