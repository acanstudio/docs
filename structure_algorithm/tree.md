树
===

树的定义
-----------

树(Tree)是n(n>=0)个结点的有限集。n=0时称为空树，在任意一棵非空树中：1.有且只有一个特定的称为根(Root)的结点；2. 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,..,Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。

* 度(Degree)：结点拥有的子树数称为结点的度,度为零的结点称为叶结点(Leaf)或终端结点。不为零的称为非终端结点或分支结点，除根结点外，其他分支结点也称内部结点；
* 树的度是树内各结点的度的最大值；
* 结点的孩子(Child)结点的子树的根称为该结点的孩子，该结点同时称为孩子的双亲(Parent)；
* 同一个双亲的孩子之间互称为兄弟(Sibling)；
* 结点的祖先是从根到该结点所经分支上的所有结点；
* 以某结点为根的子树中的任一结点都称为该结点的子孙；
* 结点的层次(Level)，从跟开始定义层，根为第一层，根的孩子为第二层，对于第i层的结点，其子树的根就在第i+1层；双亲在同一层的结点互为堂兄弟；
* 树的深度或高度(Depth)，树的层数；
* 如果树中结点的各子树从左到右是有次序的，不能互换，则称该树为有序树，否则称为无序树；
* 森林(Forest)，m(m>=0)棵互不相交的树的集合；

线性结构
* 第一个数据元素无前驱；
* 最后一个数据元素无后继
* 中间元素，有且仅有一个前驱，有且仅有一个后继

树结构
* 根节点唯一，无双亲；
* 叶结点无孩子，可以多个
* 中间结点有一个双亲多个孩子

树的抽象数据类型
-----------------

<pre>
ADT 树(tree)

Data
    树是由一个根结点和若干棵子树构成，树中结点具有相同数据类型及层次关系

Operation
    InitTree(*T); // 构造空树T
    DestroyTree(*T); // 销毁树T
    CreateTree(*T, definition); // 按definition中给出树的定义来构造树
    ClearTree(*T); // 若树存在，则将树T清为空树
    TreeEmpty(*T); // 若T为空树返回true，否则返回false
    TreeDepth(*T); // 返回树的深度
    Root(T); // 返回树的根结点
    Value(T, cur_e); // cur_e 是树T中的一个结点，返回此结点的值
    Assign(T, cur_e, value); // 给树T的结点cur_e赋值为value
    Prent(T, cur_e); // 若cur_e是树T的非根结点，则返回它的双亲，否则返回空
    LeftChild(T, cur_e); // 若cur_e是树的非叶结点，则返回它的最左边的孩子否则返回空
    RightSibling(T, cur_e); // 若cur_e有右兄弟，则返回它的右兄弟
    InsertChild(*T, *p, i, c); // 其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p结点的第i棵子树
    DeleteChild(*T, *p, i); // 删除T中p所指向结点的第i棵子树

endADT
</pre>

树的存储结构
-------------

双亲表示法，以一组连续的空间存储树的结点，同时在每个结点中，附设一个指针指向其双亲结点。
<pre>
// 树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType; // 树结点的数据类型
typedef struct PTNode // 结点结构
{
  TElemType data; // 结点数据
  int parent; // 双亲位置
  //int firstchild; // 长子位置
  //int rightsib; // 右兄弟位置
} PTNode;
typedef struct // 树结构
{
  PTNode nodes[MAX_TREE_SIZE]; // 结点数组
  int r, n; // 根的位置和节点数
} PTree;
</pre>

孩子表示法，把每个结点的孩子结点排列起来，以单链表作存储结构，n个结点偶n个孩子链表，叶子结点对应的链表为空；n个链表的头指针组成一个线性表，用顺序存储结构存放在一个一维数组中。涉及到两种结点结构，一个孩子链表的孩子结点，数据域存放孩子结点在表头数组中的下标，指针域指向下一个孩子的结点指针；表头数组的表头结点，数据域存放结点数据信息，指针域指向孩子链表的头指针。
<pre>
// 孩子表示法结构定义
#define MAX_TREE_SIZE 100;
typedef strcut CTNode // 孩子结点
{
  int child;
  struct CTNode *next;
} *ChildPtr;

typedef struct // 表头结构
{
  TElemType data;
  ChildPtr firstchild;
  //int parent; // 双亲位置
} CTBox;

typedef struct // 树结构
{
  CTBox nodes[MAX_TREE_SIZE]; 
  int r, n; // 根的位置和节点数
} CTree;
</pre>

孩子兄弟表示法，任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟若果存在也是唯一的，因此，设置两个指针分别指向该结点的第一个孩子和该结点的右兄弟。
<pre>
// 输的孩子兄弟表示法
typedef struct CSNode
{
  TElemType data;
  struct CSNode *firstchild, *rightlib;
} CSNode, *CSTree;
</pre>

二叉树的定义
----------------

二叉树(Binary Tree)是n(n>=0)个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个根结点和两棵互不相交的、分别成为根结点的左子树和右子树的二叉树组成。

二叉树的特点
* 每个结点最多有两棵子树；
* 左子树和右子树是有序的；
* 某结点即便只有一棵子树，也要指明是左子树还是右子树；

二叉树的五种形态
* 空二叉树
* 只有一个根结点
* 只有左子树
* 只有右子树
* 既有左子树又有右子树

特殊二叉树
* 斜树，所有结点都只有左子树的叫左斜树，只有右子树的叫右斜树；斜树每层只有一个结点；
* 满二叉树，在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的树称为满二叉树；
* 完全二叉树，对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号i的结点在二叉树中位置完全相同，则该二叉树称为完全二叉树；

完全二叉树的特点
* 叶子结点只能出现在最后两层；
* 最下层叶子一定集中在做不连线位置
* 倒数第二层，如果有叶子结点一定都在右部连续位置
* 不存在只有右子树的结点
* 同样结点数的二叉树，完全二叉树的深度最小

二叉树的性质
--------------

* 在二叉树的第i层上至多有2^(i-1)个结点(i>=1);
* 深度为k的二叉树至多有2^k - 1 个结点；
* 对任何一棵二叉树T，如果其终端结点数为n0，度数为2的节点数为n2，则n0=n2+1；
* 具有n个结点的完全二叉树深度为tail(log<2>n) + 1；
* 如果对一棵有n个结点的完全二叉树的结点按层序编号，对任一结点i(1<=i<=n)有，1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲结点是tail(i/2)；2. 如果2i>n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i；3. 如果2i+1>n，则结点i无右孩子，否则其右孩子是结点2i+1；

二叉树的存储结构
-----------------

由于二叉树定义严格，通过简单的顺序存储结构就能表现出二叉树的结构来；对于非完全二叉树，可以先补充为完全二叉树，然后使用顺序存储结构存储，对不存在的结点使用特殊符号标识就行，可能造成存储空间的浪费。

二叉链表，二叉树每个结点最多有两个孩子，所以可以设计一个数据域和两个指针域分别指向左右子树，这样的链表叫二叉链表。
<pre>
// 二叉链表结点结构定义
typedef struct BiTNode 
{
  TElemType data; // 结点数据
  struct BiTNode *lchild, *rchild; // 左右孩子指针
} BiTNode, *BiTree;

</pre>

遍历二叉树
-------------

二叉树的遍历(traversing binary tree)是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。

* 前序遍历：若二叉树为空，则返回空，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树；
* 中序遍历：若树为空，返回空，否则从根结点开始(不是访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后再中序遍历右子树；
* 后序遍历：若树为空，返回空，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点；
* 层序遍历：若树为空，返回空，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问；

前序遍历递归算法
<pre>
void PreOrderTraverse(BiTree T)
{
  if (T == null) {
    return false;
  }
  printf("%c ", T->data);
  PreOrderTravese(T->lchild); // 前序遍历左子树
  PreOrderTravese(T->rchild); // 前序遍历右子树
}
</pre>

中序遍历递归算法
<pre>
void InOrderTraverse(BiTree T)
{
  if (T == null) {
    return false;
  }
  InOrderTravese(T->lchild); // 前序遍历左子树
  printf("%c ", T->data);
  InOrderTravese(T->rchild); // 前序遍历右子树
}
</pre>

后序遍历递归算法
<pre>
void PostOrderTraverse(BiTree T)
{
  if (T == null) {
    return false;
  }
  PostOrderTravese(T->lchild); // 前序遍历左子树
  PostOrderTravese(T->rchild); // 前序遍历右子树
  printf("%c ", T->data);
}
</pre>

已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树；已知前序和后续序列，不能确定一棵二叉树。

二叉树的建立
--------------

通过对普通二叉树进行扩展即将二叉树中每个结点的空指针引出一个虚节点。基于扩展后的二叉树可以方便地在内存中生成一棵二叉树。

<pre>
// 按前序输入二叉树中结点的值(一个字符)
// #标识空树，构造二叉链表标识二叉树T
void CreateBiTree(BiTree *T)
{
  TElemType ch;
  scanf("%c", &ch);
  if (ch == '#') {
    *T = null;
  } else {
    *T = (BiTree) malloc(sizeof(BiTNode));
    if (!*T) {
      exit(OVERFLOW);
    }
    (*T)->data = ch; // 生成根结点
    CreateBiTree(&(*T)->lchild);  // 构造左子树
    CreateBiTree(&(*T)->rchild);  // 构造右子树
  }
}
</pre>

线索二叉树
--------------

树、森林与二叉树的转换
-----------------------

树转换为二叉树
* 加线，在所有兄弟结点之间加一条连线
* 去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线
* 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明，第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子；

森林转换为二叉树
* 把每棵子树转换为二叉树；
* 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来，最终形成二叉树；

二叉树转换为树
* 加线，若某结点的左孩子结点存在，则将该结点左孩子的n个右孩子结点都作为此结点的孩子，将该结点与这些右孩子用线连接起来；
* 去线，删除原二叉树中所有结点与其右孩子结点的连线；
* 调整层次；

二叉树转换为森林
* 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，直到所有右孩子连线都删除为止，得到分离的二叉树；
* 再将每棵分离后的二叉树转换为树即可；

树的遍历：
* 先根遍历，先访问树的根结点，然后依次先根遍历每棵子树
* 后根遍历，先依次后根遍历每棵子树，然后再访问根结点；

森林的遍历
* 前序遍历，先访问森林中的第一棵树的根结点，然后再依次先根遍历根的每棵子树；再依次用同样方式遍历剩余的森林；
* 后续遍历，针对第一棵树，后根遍历方式遍历每棵子树，然后再访问根结点；然后再用同样方式遍历剩余的森林；

森林的前序遍历和对应二叉树的前序遍历结果相同；森林的后序遍历与对应的二叉树的中序遍历结果相同；
树的先根遍历和后根遍历与对应二叉树的前序遍历和中序遍历结果相同；

赫夫曼树及其应用
-------------------

总结
---------
